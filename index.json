[{"categories":["日常"],"content":"当在家里要上谷歌查个资料，用snap在Linux上安装个软件，上youtube找个视频教程，下载个安卓sdk的时候就难免要用到网络加速工具。关于网络加速，很多人会使用路由器上的功能或者是直接使用软路由或是旁路由来解决这个问题，但是我这手上没有合适的硬件，而且我也就在家里使用网络的时候才会用到网络加速，没必要专门启动一个二十四小时工作的设备。这一篇就记录下在自己的个人家用服务器上搭建网络加速工具链的方法。 ","date":"2021-03-14","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%BA%8C%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/:0:0","tags":["Linux","Ubuntu"],"title":"个人家用服务器搭建记录（二）网络加速","uri":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%BA%8C%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"},{"categories":["日常"],"content":"涉及软件 主要涉及的软件有： Clash（VMess协议加速，并提供本地HTTP，HTTPS，SOCKS5端口服务） subconverter（订阅转换，生成Clash配置文件） yacd（Clash的web面板） ","date":"2021-03-14","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%BA%8C%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/:1:0","tags":["Linux","Ubuntu"],"title":"个人家用服务器搭建记录（二）网络加速","uri":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%BA%8C%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"},{"categories":["日常"],"content":"部署Clash Clash使用Golang写的，在Ubuntu上启动起来也比较简单。首先在clash的releases中下载clash-linux-amd64的包，在本地用gunzip命令解压后，直接使用./clash就可以启动了。 在启动的时候会在~/.config/clash生成配置文件夹，里面会有config.yaml和Country.mmdb文件。在第一次启动的时候clash会去下载Country.mmdb文件，但是由于网络原因有失败的可能，如果失败，可以在有网络加速环境的地方自己手动下载Country.mmdb文件，再手动上传到配置文件目录下。 如果需要后台启动使用命令nohup ./clash \u0026 就可以后台启动了。但是个人不推荐这样做，还是建议把服务的启动关停交给systemd管理。 首先在/etc/systemd/system文件夹下新建service文件： vim /etc/systemd/system/clash.service service文件的内容： Description=clash #下面的两条配置表示依赖网络服务 After=network-online.target Wants=network-online.target [Service] Type=simple User=hao #用户名 ExecStart=/home/hao/clash/clash #启动命令 ExecStop=/bin/kill -s QUIT $MAINPID #停止命令 Restart=always StandOutput=syslog StandError=inherit [Install] WantedBy=multi-user.target 编辑完成保存后重载systemd并启动服务，下面是可能会用到的命令： systemctl daemon-reload #重载systemd systemctl start clash #启动 systemctl stop clash #关闭 systemctl enable clash #开机启动 systemctl disable clash #取消开机启动 systemctl status clash #查看状态 这样的话就可以把clash交给systemd来管理启动、关闭和开机启动了。 如果服务提供商提供了clash订阅的配置文件下载地址，那就直接下载文件，覆盖到clash配置文件目录下并重启clash，就可以开始使用了。 wget \"https://abc.xyz/aabbcc\" -O /home/hao/.config/clash/config.yaml sudo systemctl restart clash 如果服务商没有提供clash的配置文件，那么就需要从其他的订阅链接转换成clash配置文件，那么就要用到下面说的subconverter了。 ","date":"2021-03-14","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%BA%8C%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/:2:0","tags":["Linux","Ubuntu"],"title":"个人家用服务器搭建记录（二）网络加速","uri":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%BA%8C%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"},{"categories":["日常"],"content":"使用docker安装subconverter docker的安装就不写了，直接参照官方文档 Install Docker Engine on Ubuntu 安装即可。 然后直接把subconverter的docker镜像拖下来 docker pull tindy2013/subconverter 按照作者提供的文档 subconverter-docker 启动即可 # 运行并且将容器25500端口映射到宿主机25500 docker run -d --restart=always -p 25500:25500 tindy2013/subconverter:latest # 检查状态 curl http://localhost:25500/version # 如果显示“subconverter vx.x.x backend”说明已经正常启动 订阅转换我是配合ACL4SSR规则进行转换的，因为需要访问https://raw.githubusercontent.com/，在进行订阅转换的时候也需要加速，为了让订阅更新更加灵活可用，除了这个不走代理的容器，我这边还会启动一个默认走代理的容器。 关于Docker的加速方式，找到了一篇文章介绍的很详细，Docker 代理脱坑指南，这里就使用Dockerfile的方式。 先写一个Dockerfile，在原来的镜像的基础上配置全局代理，MY_PROXY_URL的值就是clash的http服务路径 FROMtindy2013/subconverter:latestENV MY_PROXY_URL=\"http://192.168.3.18:7890\"ENV HTTP_PROXY=$MY_PROXY_URL \\ HTTPS_PROXY=$MY_PROXY_URL \\ http_proxy=$MY_PROXY_URL \\ https_proxy=$MY_PROXY_URLEXPOSE25500构建镜像 docker build -t subconventer-custom-proxy:latest 之后再用这个镜像启动一个容器，并分配一个别的端口，我这里映射到了25501上 docker run -d --restart=always -p 25501:25500 subconventer-custom-proxy:latest 关于获取转换订阅的连接，虽然可以啃subconventer的文档，但是也有现成的获取订阅转换的连接的工具sub-web，ACL4SSR的订阅转换网址 acl4ssr.netlify.app 因为生成一次链接可以一直使用，使用频率很低，所以我就懒得在本地部署了。之后直接用获取的定制订阅链接访问subconventer服务，就可以获得转换过可以直接使用的clash配置文件了。 ","date":"2021-03-14","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%BA%8C%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/:3:0","tags":["Linux","Ubuntu"],"title":"个人家用服务器搭建记录（二）网络加速","uri":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%BA%8C%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"},{"categories":["日常"],"content":"在nginx上部署yacd面板 为了方便切换节点之类的操作，在本地部署了一个yacd面板。可以直接部署的yacd静态页面包在yacd的github页面上的readme里有提供： zip of the gh-pages 直接打开文件夹，打开index.html，设置好clash的管理api端口地址就能用了，但是为了方便在手机和其他设备上使用，我把这些文件部署到了nginx上。 nginx直接安装就行 apt install nginx 然后把之前获取的yacd静态页面的文件夹移动到一个固定的目录下比如mysite，然后为nginx添加一个配置文件mysite server { listen 81; server_name 192.168.3.18; location /yacd { root /home/hao/mysite/; index index.html; } } 保存之后重启nginx服务，访问http://192.168.3.18:81/yacd即可访问，具体的地址，端口和文件目录需要按照实际情况配置。 ","date":"2021-03-14","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%BA%8C%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/:4:0","tags":["Linux","Ubuntu"],"title":"个人家用服务器搭建记录（二）网络加速","uri":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%BA%8C%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"},{"categories":["日常"],"content":"使用加速功能 要使用加速功能其实就是把流量转发到clash提供的http或socks5端口上去，浏览器上的插件SwitchyOmega，安卓手机上的BifrostV，ios上大名鼎鼎的小飞机，都可以设置把流量转发到socks5端口上。在系统的代理设置里也可以手动设置，从而达到全局代理的目的。很多软件也有代理设置的地方，这样就不需要全局代理，仅在个别软件上加速。windows上的SStap和Linux上经过设置的iptables甚至可以转发udp流量。 这样的话整个用于网络加速的工具链就搭建好了。 ","date":"2021-03-14","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%BA%8C%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/:5:0","tags":["Linux","Ubuntu"],"title":"个人家用服务器搭建记录（二）网络加速","uri":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%BA%8C%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"},{"categories":["日常"],"content":"硬件选择 家中有一个闲置的笔记本，想要趁这个机会利用起来，型号为宏碁Aspire E5-551G，处理器AMD A8-7100，4G内存，因为AMD核显的原因实际可用内存3.2G不到，硬盘500G机械。之前在这台电脑上预装的win8.1在机械硬盘和这个性能孱弱的apu上跑的非常吃力，体验十分差。后来还折腾装了win10 ltsc，体验也一般。后来就像干脆就装个Linux，偶尔用下图形界面，大部分时间用来跑服务就行了，反正主力台式机和笔记本都有。这台机器在之前装windows挂下载的时候就显现出来了一个毛病，因为家中的布局，不方便拉网线到我的房间，房子也老，当时也没有墙内的线路，只能用无线网。然而内置的无线网卡不知道是性能实在太差还是天线之类的部件老化了，网络信号很差而且十分不稳定，挂下载速度基本跑不满，而且挂一段时间之后网速就变得特别慢，需要重启电脑才正常。本来是想要更换一个内置无线网卡的，但是考虑到万一是天线或其他部件出问题那不是白忙活，所以最后还是决定配一个usb无线网卡，最终选定了腾达U12，网卡型号为瑞昱的rtl8812AU，这个网卡我之前搜索过有Linux驱动，而且支持USB3.0，造型不夸张，价格也合适，送一根USB延长线，方便把无线网卡部到信号更好的位置。 ","date":"2021-03-10","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%B8%80%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F/:1:0","tags":["Linux","Ubuntu"],"title":"个人家用服务器搭建记录（一）硬件与系统","uri":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%B8%80%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F/"},{"categories":["日常"],"content":"系统选择 之前就在笔记本上装过Windows加Linux的双系统，这次是第一次在实体机上装纯Linux系统，所以决定选择中文资料更多更好找的Ubuntu。本来只用来跑服务装Ubuntu Server就行，但是还是想有个桌面环境以备不时之需。Ubuntu默认的Gnome桌面有些太占资源了，不太适合我的旧笔记本，所以最后选择了xfce桌面的Xubuntu，版本就选择最近的LTS版本，20.04 LTS。 ","date":"2021-03-10","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%B8%80%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F/:2:0","tags":["Linux","Ubuntu"],"title":"个人家用服务器搭建记录（一）硬件与系统","uri":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%B8%80%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F/"},{"categories":["日常"],"content":"系统与驱动安装 系统安装也没什么好说的，直接有图形界面，说这方面的文章也很多，而且这个系统已经装好几个月了，细节也记不清了，况且不用装双系统，需要注意的细节也很少。关于装双系统或者多系统的自己现在也算是有一些经验，之后再专门写篇文章详细说说。刚装好系统后首先需要的就是装驱动了，AMD显卡的驱动已经默认装好了，就不用折腾了，唯一需要装的驱动就USB无线网卡rtl8812AU的驱动。关于装这个驱动中间也走了一些弯路。虽然Ubuntu在网络上能搜索到的资料很多，但是也有很多老旧过时的资料混在里面，查找到的一些文章里提及的驱动程序很多都比较老，而且有的原作者已经不维护了，导致我按照教程安装之后没用，不过后来终于在Github找到了一个有用的，就是这个rtl8812au-5.9.3.2，根据作者在readme里写的，我在写这篇文章时的版本已经可以在5.4, 5.8, 5.9, 5.10, 5.11的内核下编译成功，在5.4内核下完整的测试过，就我目前使用的情况来看没发现什么问题。readme里也写了用dkms安装驱动的方法，我就直接粘过来了： To use dkms install: (as root, or sudo) copy source folder contents to /usr/src/rtl8812au-5.9.3.2 sudo dkms add -m rtl8812au -v 5.9.3.2\rsudo dkms build -m rtl8812au -v 5.9.3.2\rsudo dkms install -m rtl8812au -v 5.9.3.2\rTo use dkms uninstall and remove: sudo dkms remove -m rtl8812au -v 5.9.3.2 --all\r我在我自己的设备上编译安装成功，已经稳定使用了几个月，没出现过什么问题。 因为有原本的内置无线网卡，现在还需要把内置的无线网卡禁用： sudo apt install net-tools #安装网络工具\rifconfig #查询网卡名称\rifconfig 网卡名 down\r这样系统就可以正常使用了。进路由器管理端搞个固定ip，就可以愉快的跑服务了。 ","date":"2021-03-10","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%B8%80%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F/:3:0","tags":["Linux","Ubuntu"],"title":"个人家用服务器搭建记录（一）硬件与系统","uri":"/posts/%E4%B8%AA%E4%BA%BA%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%E4%B8%80%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F/"},{"categories":["日常"],"content":"在荒废了一年多之后，终于要重新开始写博客了，博客系统已经迁移到hugo，主题用的是LoveIt，写md从之前的vscode也换成了好用的Typora。关于LoveIt主题的配置，文档里写的很详细了，耐下心来对着配置就ok了，配置文件找个地方备份下也就ok了，这里就稍微记录下hugo写博客需要用到的命令吧。 ","date":"2021-03-07","objectID":"/posts/%E5%A5%BD%E8%80%B6/:0:0","tags":["hugo"],"title":"好耶","uri":"/posts/%E5%A5%BD%E8%80%B6/"},{"categories":["日常"],"content":"生成站点 hugo new site /home/hao/myblog ","date":"2021-03-07","objectID":"/posts/%E5%A5%BD%E8%80%B6/:1:0","tags":["hugo"],"title":"好耶","uri":"/posts/%E5%A5%BD%E8%80%B6/"},{"categories":["日常"],"content":"新建博客 hugo new posts/好耶.md ","date":"2021-03-07","objectID":"/posts/%E5%A5%BD%E8%80%B6/:2:0","tags":["hugo"],"title":"好耶","uri":"/posts/%E5%A5%BD%E8%80%B6/"},{"categories":["日常"],"content":"启动预览 因为hugo是装在了另一台机器上，所以有些参数需要添加 hugo serve --disableFastRender --bind 192.168.3.18 -p 1313 --baseURL=http://192.168.3.18 disableFastRender 禁用快速渲染 bind 192.168.3.18 -p 1313 指定访问的ip和端口 baseURL=http://192.168.3.18 指定baseURL ","date":"2021-03-07","objectID":"/posts/%E5%A5%BD%E8%80%B6/:3:0","tags":["hugo"],"title":"好耶","uri":"/posts/%E5%A5%BD%E8%80%B6/"},{"categories":["日常"],"content":"部署博客 首先在博客根目录执行hugo命令，静态文件就会在public目录下生成，第一次提交需要初始化public目录为git本地仓库并关联github上的远程仓库 git init git remote add origin https://github.com/jgduhao/jgduhao.github.io.git 然后在public目录执行git提交命令就行了 git add -A git commit -m \"move to hugo\" git push -u origin master 因为我是从别的博客迁移过来的，所以我是先把之前的文件pull下来，删除干净，push到远程仓库之后再用hugo命令生成hugo的博客文件，之后再push的。 顺便说下Typora是真的好用，码字的同时就让你能看到成品的美观页面，对写博客的正反馈真的很强。 ","date":"2021-03-07","objectID":"/posts/%E5%A5%BD%E8%80%B6/:4:0","tags":["hugo"],"title":"好耶","uri":"/posts/%E5%A5%BD%E8%80%B6/"},{"categories":["日常"],"content":"进入安装界面 首先在进入安装界面的时候显示器会提示超出范围，这个应该是安装程序检测硬件时有问题，自己的电脑是uefi引导，所以在Installation出按e，在linuxefi的那一行的最后加上“nomodeset”，然后按F10启动安装就行了。 ","date":"2021-03-07","objectID":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/:1:0","tags":["Linux","openSUSE"],"title":"openSUSE Tumbleweed桌面安装要点记录","uri":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"},{"categories":["日常"],"content":"安装过程 安装的时候记得选择一定记得选择简体中文，别闭着眼睛点下一步就全跳过去了，选了简体中文，字体和输入法就都给你准备好了。 网络管理记得选NetworkManager，方便配合KDE Plasma使用。 ","date":"2021-03-07","objectID":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/:2:0","tags":["Linux","openSUSE"],"title":"openSUSE Tumbleweed桌面安装要点记录","uri":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"},{"categories":["日常"],"content":"安装完成后进入系统的配置 建议延长KDE Plasma自带的更新检查时间，并且无视更新提醒，因为会和zypper冲突。 安装Nvidia驱动：打开YaST工具，选择软件源配置，添加软件源：https://download.nvidia.com/opensuse/tumbleweed，然后打开软件管理功能，选择最新的驱动安装即可。 安装解码器：添加Packman软件源，然后再安装，其实可以直接用火狐浏览器访问opensuse-community（大概需要富强）用里面提供的按钮一键安装（自动添加软件源和安装解码器包），安装完成之后还是在YaST选择软件管理，在视图里选择软件源，选择Packman软件源，选择“切换系统包”，确保今后这些包的更新都来自Packman源。 其他的软件都没什么好说的，直接参照openSUSE维基上的第三方软件源添加即可。如果不知道有没有自己想要的软件，可以访问 openSUSE软件，除了官方提供的源可以使用网页上的按钮一键安装，也可以使用社区软件包（类似于Arch的AUR），或者也可以使用snap来补充软件比如Visual Studio Code或者Typora（之前看到b站上的视频说openSUSE上Typora没人打包，大概是因为snap上就有），参照 Installing snap on openSUSE。 snap加速：为snap设置代理 sudo snap set system proxy.https=socks5://127.0.0.1:1080\rsudo snap set system proxy.http=socks5://127.0.0.1:1080\r ","date":"2021-03-07","objectID":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/:3:0","tags":["Linux","openSUSE"],"title":"openSUSE Tumbleweed桌面安装要点记录","uri":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"},{"categories":["日常"],"content":"滚动升级 openSUSE Tumbleweed是滚动升级的版本，使用 pacman -Syu zypper dup升级系统。 ","date":"2021-03-07","objectID":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/:4:0","tags":["Linux","openSUSE"],"title":"openSUSE Tumbleweed桌面安装要点记录","uri":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"},{"categories":["日常"],"content":"总结 个人觉得安装和使用都是比较好上手的，默认的KDE Plasma就足够好看了，中文字体的显示效果也很不错（manjaro默认的中文字体显示效果让我很不满意，包括KDE Plasma版和Gnome版），几乎不需要再多折腾。安装软件虽然没有AUR来的爽，但是有图形界面与网页一键安装，易用性不错。而且软件包也足够新，昨天装上后就直接用上了KDE Plasma 5.21和5.10Linux内核，够爽，一点没有老牌发行版背着沉重的历史包袱的感觉，整体给我的印象非常好。 ","date":"2021-03-07","objectID":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/:5:0","tags":["Linux","openSUSE"],"title":"openSUSE Tumbleweed桌面安装要点记录","uri":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"},{"categories":["日常"],"content":"安装后第一件事 换国内源 sudo pacman-mirrors -i -c China -m rank\rsudo pacman -Syy\rsudo pacman -Syu\r安装中文输入法 安装fcitx-libpinyin（也可以是sunpinyin等） 安装kcm-fcitx（kde桌面的输入法管理） 编辑配置文件~/.pam_environment GTK_IM_MODULE DEFAULT=fcitx\rQT_IM_MODULE DEFAULT=fcitx\rXMODIFIERS DEFAULT=@im=fcitx\r重新登录生效 如果不是有旺盛的中文输入需求就不要折腾搜狗输入法了 ","date":"2021-02-24","objectID":"/posts/manjaro%E7%AC%AC%E4%B8%80%E6%97%A5%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:0","tags":["Linux","Manjaro"],"title":"Manjaro使用第一日总结","uri":"/posts/manjaro%E7%AC%AC%E4%B8%80%E6%97%A5%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["日常"],"content":"总结 如非必要，不要随意添加archlinuxcn源 谨慎对待搜索引擎上的教程，比起轻率的敲安装命令不如使用图形界面的“添加/删除软件功能”搜索包后安装 比起用搜索引擎搜索出一大堆过时的文章，不如直接去蹭archlinux wiki的课，例如中文输入法的问题，搜索引擎上有一大堆折腾搜狗输入法的文章与过时文章（还有过于激进的解决方案），其实直接参阅archlinux wiki的fcitx章节就可以轻松无痛的解决基本的中文输入的需求（只要不是非搜狗输入法不可），不过arch与manjaro毕竟不是一个系统，在实践wiki上的方法先去搜索相应的包，再决定是否安装。 ","date":"2021-02-24","objectID":"/posts/manjaro%E7%AC%AC%E4%B8%80%E6%97%A5%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:0","tags":["Linux","Manjaro"],"title":"Manjaro使用第一日总结","uri":"/posts/manjaro%E7%AC%AC%E4%B8%80%E6%97%A5%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["学习记录"],"content":"为什么是Groovy？ 要说Groovy一直都不是多火的东西，同时作为JVM上的语言，完全没有近年来谷歌强推的Kotlin火，但是学语言嘛，最重要的是开心，特别是工作中不是必须要用的语言。平常自己写一些辅助工作的小功能会用Java，像这类东西肯定是脚本语言更加适合，也自己学了一点热门的Python，但毕竟工作中一点都不用，想写个功能还得翻翻文档，而Java工作中常用，api根本不用看直接用，Python的效率优势反而没了，结果工作中常用的Java和JavaScript越来越熟练，Python就荒废了。但不得不说Java在写一些功能的时候是真的不爽，比如集合操作，工作中也写一点JavaScript，比较之下就更加不爽，之后Groovy在偶然的机会下就进入视线，试着用了一下，还真挺有意思，就开始想着认真学一下，要说自己为什么想学Groovy，大概就下面几点： 脚本语言，直接写直接用 兼容Java语法，学习曲线平滑 介绍中看到DSL相关的东西，觉得能拿来做些有意思的东西 看到有不少用Groovy给Java写单元测试的用法，感觉可以给工作上带来帮助 而且在网上还看到一个很有意思的说法，Groovy是真正的JavaScript，我也总结了一下： 虚假的JavaScript 真正的JavaScript 可以在各种浏览器上运行，靠v8引擎和node.js也可以在服务端运行，但就是不能在JVM上运行 在JVM上运行 语法与api和Java有相似之处，但也有大量不同的地方 可以直接写Java代码 动态语言 动态语言，但是可以设置静态编译，能屈能伸 蹭热度的名字，一开始叫LiveScript groovy：adj.时髦的; 吸引人的; 有趣的 包含美好的寓意 当然上面是开玩笑的，不过也体现出了Groovy吸引Java开发人员的地方。 ","date":"2019-07-07","objectID":"/posts/groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/:0:1","tags":["Groovy"],"title":"Groovy学习记录（一）","uri":"/posts/groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/"},{"categories":["学习记录"],"content":"快速开始 确实够快，因为做Java开发，肯定是有JDK的，只要再下载一个Groovy 50多M的包，解压之后把bin目录配置进Path变量就行了。 输入 groovy -v 展示了Groovy Java和系统版本，安装成功。 安装好之后就有命令行Groovy Shell和图形界面的Groovy Console可以用，也可以直接文本编辑器写groovy文件，例如： print 'Hello World' 然后切换到文件所在目录输入命令 groovy hello.groovy 运行展示结果。 初步学习就是看官方文档，先把 Differences with Java 和 The Groovy Development Kit 这两篇看个差不多就可以开始写脚本了。 自己写了两个小东西，主要是处理xml配置文件的，用到了 Processing XML 里面介绍的XmlSlurper，用起来很爽，基本上就是 def list = new XmlSlurper().parseText(text) //解析xml文本 println list.technology.name //直接取值 println list.technology.@name //取属性 list.technology.each { it -\u003e println it.@name //直接遍历 } 就行了，简单愉快。 遍历目录： //遍历所有文件和文件夹 new File('/path').eachFileRecurse { file -\u003e println file.name } 定义集合与遍历集合： //列表 def list = [5, 6, 7, 8] list.each { println \"Item: $it\" } //Map def map = [name: 'Gromit', likes: 'cheese', id: 1234] def map2 = [ simple : 123, complex: [a: 1, b: 2] ] map.each { key, value -\u003e println \"key: $key val: $value\" } 舒服了。 还有个用的比较多的就是GString，Groovy中单引号是普通字符串，双引号是GString，可以直接用类似字符串模板的写法，上面已经出现过了: def map = [name: 'Gromit', likes: 'cheese', id: 1234] map.each { key, value -\u003e println \"key: $key val: ${value.toUpperCase()}\" } 有了这些其实就已经能提高不少效率了，而且为什么说Groovy学习曲线平滑？因为有的地方如果不太熟悉Groovy的api，可以去翻文档，也可以直接上自己熟悉的Java写法搞定的，效率UP。 ","date":"2019-07-07","objectID":"/posts/groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/:0:2","tags":["Groovy"],"title":"Groovy学习记录（一）","uri":"/posts/groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/"},{"categories":["学习记录"],"content":"Groovy in Action Groovy中文资料还是有点少，Groovy in Action第一版倒是有中文的，但那都是07年的书了，年代有点久远，所以干脆就直接挑战一下Groovy in Action 第二版的英文版，锻炼一下自己阅读英文书籍的能力。目前看完了Part1的第一章和第二章。 第一章基本就是Groovy大型广告，介绍了Groovy的故事，Groovy的使用场景，快速开始和支持Groovy的IDE与文本编辑器的介绍。 第二章也是介绍了Groovy的一些基础内容，到没有一上来就讲什么运算符数据类型之类了，而是讲了和Java语法的比较，assert的用法，还有一些GroovyBeans，注解，grapes，GStrings，正则表达式，数字，集合，闭包，流程控制语句大致的介绍，其中有一点就是Groovy中的数字类型也是对象，所以会看到 1.plus(2) 这种看着怪怪的写法。 接下来就是Groovy编译器相关的内容。这里说到了有意思的一点，Groovy虽然是动态语言，但是与用解释器逐行解释的动态语言不同，Groovy是经过编译器编译再运行的，但是编译之后又怎么做到动态语言的特性的呢？以调用方法为例子，编译后的文件里不是直接调用的，而是 getMetaClass().invokeMethod(this, \"foo\", EMPTY_PARAMS_ARRAY) 这样通过MetaClass对象进行调用，通过MetaClass对象可以实现动态语言的特性。 而使用注解 @CompileStatic 之后编译出来的文件就不去使用MetaClass对象调用方法。 总之趁着自己还有学习热情的时候多看点吧。 ","date":"2019-07-07","objectID":"/posts/groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/:0:3","tags":["Groovy"],"title":"Groovy学习记录（一）","uri":"/posts/groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/"},{"categories":["工作记录"],"content":"目前做的是网金方面的外包，因为涉及敏感信息，所以就在不涉及到具体信息的情况下记录一下面对生产问题时，让自己印象比较深刻的一些不成熟排查的思路与解决过程，方便回顾，总结与进步。 ","date":"2019-07-05","objectID":"/posts/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95%E4%B8%80/:0:0","tags":["Java","Apache"],"title":"生产问题排查记录（一）","uri":"/posts/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95%E4%B8%80/"},{"categories":["工作记录"],"content":"问题描述：客户无法登录，错误提示信息为空 背景信息 收到客户反馈，无法登录并且弹出了空的错误信息，具体询问客户表示在某个时间点之前可以正常使用，但是那之后就无法使用了。 网络大致架构为： 服务H（Apache 静态资源服务器） -\u003e 服务G（Weblogic 主要负责会话控制等公共业务） -\u003e 服务S（Weblogic 负责具体业务逻辑） 由于服务S负责具体的业务逻辑，所以在服务G上的日志可以很方便的检索与跟踪，服务G上由于主要负责一些简单流程，日志记录格式不好，查找也不怎么方便。而Apache上就只有http请求日志。这就造成了在查找日志跟踪问题时并不是H到G再到S的正常顺序，而是按照日志获取难易程度进行查找的，也就是反过来的S到G再到H，这样做的弊端也就在这次错误排查中显现了。 排查过程 首先找到了客户的登录请求，请求成功到服务S并且成功返回，查看时间戳，也在正常时间内执行完毕，没有超时，看上去一切正常，可是客户的浏览器并未受到这一笔返回报文。接着排查服务G，寻找到服务G上客户的请求信息，也是正常接收请求，在正常的时间内返回，看上去也是一切正常。这时候本应该继续排查服务H，跟踪客户的http请求响应码是否正常，但是由于经验不足，同时http请求量较大，不便排查，而且服务H上没有任何业务逻辑，惯性思维下也就暂时忽略了服务H的排查，事实证明就是这一点导致走了弯路。然后此时就只能推测是客户的网络问题，询问后得知在相同设备上换别的账户可以登录，同时此账户在别的设备别的网络上也无法登录。 暂时没有了其他线索，只能再去仔细排查一遍代码。排查之后发现了重要的一点，在登录成功之后服务G向服务S请求了一部分客户数据放入会话，而这一请求可能会导致拖慢请求速度，为了保证性能，服务S提供数据的接口有一个标志位，可以在放弃一部分在某些场景下不需要的数据来提高性能。可是服务S上这个接口的标志位字段在不知道什么时候修改过， 而服务G在请求时的字段居然没有修改！ 这就导致了这个标志位失效，所有的请求都会变得较为耗时。回过头去看服务G上的日志，发现这名客户因为其账户原因，正好这一请求较为耗时，但是并未超时。最终还是去排查了服务H，发现 使用的Apache服务器在前几天升级了版本，然而开发人员居然不知情！ 而Apache服务器升级的日志就是客户无法正常使用的时间点。排查其配置文件，发现配置的超时时间比之前短了一倍以上，这就导致Apache超时时间短于Weblogic超时时间，而客户的登录请求时间正好比Apache超时时间长了一点，这就导致Weblogic上虽然没超时，Apache上已经判定为超时并返回错误码了，而Apache返回的http错误码在前端代码的ajax请求回调内并未妥善处理，导致了一个意义不明的提示信息。 解决方案 现在问题就很简单了，首先把Apache超时时间调整到合适的时间，调整完成后得到客户反馈，问题解决。然后就是修改代码，修复不一致的标志位，去掉不必要的数据请求，降低交易时间，搞定，提交上线申请。 反思与总结 回过头来看下其实是个并不复杂的问题，如果排查顺序正常，就能很快查出问题所在，如果知道Apache服务器最近升级版本，也能很快察觉到问题所在，如果能一直及时维护的接口文档，就能从根源上杜绝这个问题的发生。 ","date":"2019-07-05","objectID":"/posts/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95%E4%B8%80/:0:1","tags":["Java","Apache"],"title":"生产问题排查记录（一）","uri":"/posts/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95%E4%B8%80/"},{"categories":["日常"],"content":"经历了一点微小的困难终于能写第一篇博客了，无内鬼，来点MarkDown语法 这是一级标题 ","date":"2019-07-05","objectID":"/posts/helloworld/:0:0","tags":["MarkDown"],"title":"helloworld","uri":"/posts/helloworld/"},{"categories":["日常"],"content":"这是二级 ","date":"2019-07-05","objectID":"/posts/helloworld/:1:0","tags":["MarkDown"],"title":"helloworld","uri":"/posts/helloworld/"},{"categories":["日常"],"content":"这是三级 这是四级 # 这是一级标题 ## 这是二级 ### 这是三级 #### 这是四级 上面是分割线 *** 上面是分割线 下面是无序列表 1 2 3 下面是有序列表 one two three 下面是无序列表 - 1 - 2 - 3 下面是有序列表 1. one 2. two 3. three 这里是引用 这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用 \u003e这里是引用 \u003e这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用 这是粗体 这是斜体 **这是粗体** *这是斜体* 下面是链接 我的博客 下面是图片 下面是链接 [我的博客](https://jgduhao.github.io/) 下面是图片 ![截图](https://jgduhao.github.io/images/2019-07-05_090016.png) 下面就是代码 println 'Hello World'; 够用了，重要的还是内容 ","date":"2019-07-05","objectID":"/posts/helloworld/:1:1","tags":["MarkDown"],"title":"helloworld","uri":"/posts/helloworld/"}]