[{"categories":["日常"],"content":"好耶 在荒废了一年多之后，终于要重新开始写博客了，博客系统已经迁移到hugo，主题用的是LoveIt，写md从之前的vscode也换成了好用的Typora。关于LoveIt主题的配置，文档里写的很详细了，耐下心来对着配置就ok了，配置文件找个地方备份下也就ok了，这里就稍微记录下hugo写博客需要用到的命令吧。 ","date":"2021-03-07","objectID":"/posts/%E5%A5%BD%E8%80%B6/:0:0","tags":["hugo"],"title":"好耶","uri":"/posts/%E5%A5%BD%E8%80%B6/"},{"categories":["日常"],"content":"生成站点 hugo new site /home/hao/myblog ","date":"2021-03-07","objectID":"/posts/%E5%A5%BD%E8%80%B6/:1:0","tags":["hugo"],"title":"好耶","uri":"/posts/%E5%A5%BD%E8%80%B6/"},{"categories":["日常"],"content":"新建博客 hugo new posts/好耶.md ","date":"2021-03-07","objectID":"/posts/%E5%A5%BD%E8%80%B6/:2:0","tags":["hugo"],"title":"好耶","uri":"/posts/%E5%A5%BD%E8%80%B6/"},{"categories":["日常"],"content":"启动预览 因为hugo是装在了另一台机器上，所以有些参数需要添加 hugo serve --disableFastRender --bind 192.168.3.18 -p 1313 --baseURL=http://192.168.3.18 disableFastRender 禁用快速渲染 bind 192.168.3.18 -p 1313 指定访问的ip和端口 baseURL=http://192.168.3.18 指定baseURL ","date":"2021-03-07","objectID":"/posts/%E5%A5%BD%E8%80%B6/:3:0","tags":["hugo"],"title":"好耶","uri":"/posts/%E5%A5%BD%E8%80%B6/"},{"categories":["日常"],"content":"部署博客 首先在博客根目录执行hugo命令，静态文件就会在public目录下生成，第一次提交需要初始化public目录为git本地仓库并关联github上的远程仓库 git init git remote add origin https://github.com/jgduhao/jgduhao.github.io.git 然后在public目录执行git提交命令就行了 git add -A git commit -m \"move to hugo\" git push -u origin master 因为我是从别的博客迁移过来的，所以我是先把之前的文件pull下来，删除干净，push到远程仓库之后再用hugo命令生成hugo的博客文件，之后再push的。 顺便说下Typora是真的好用，码字的同时就让你能看到成品的美观页面，对写博客的正反馈真的很强。 ","date":"2021-03-07","objectID":"/posts/%E5%A5%BD%E8%80%B6/:4:0","tags":["hugo"],"title":"好耶","uri":"/posts/%E5%A5%BD%E8%80%B6/"},{"categories":["学习记录","日常"],"content":"openSUSE Tumbleweed桌面安装要点记录 ","date":"2021-03-07","objectID":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/:0:0","tags":["Linux","openSUSE"],"title":"openSUSE Tumbleweed桌面安装要点记录","uri":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"},{"categories":["学习记录","日常"],"content":"进入安装界面 首先在进入安装界面的时候显示器会提示超出范围，这个应该是安装程序检测硬件时有问题，自己的电脑是uefi引导，所以在Installation出按e，在linuxefi的那一行的最后加上“nomodeset”，然后按F10启动安装就行了。 ","date":"2021-03-07","objectID":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/:1:0","tags":["Linux","openSUSE"],"title":"openSUSE Tumbleweed桌面安装要点记录","uri":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"},{"categories":["学习记录","日常"],"content":"安装过程 安装的时候记得选择一定记得选择简体中文，别闭着眼睛点下一步就全跳过去了，选了简体中文，字体和输入法就都给你准备好了。 网络管理记得选NetworkManager，方便配合KDE Plasma使用。 ","date":"2021-03-07","objectID":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/:2:0","tags":["Linux","openSUSE"],"title":"openSUSE Tumbleweed桌面安装要点记录","uri":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"},{"categories":["学习记录","日常"],"content":"安装完成后进入系统的配置 建议延长KDE Plasma自带的更新检查时间，并且无视更新提醒，因为会和zypper冲突。 安装Nvidia驱动：打开YaST工具，选择软件源配置，添加软件源：https://download.nvidia.com/opensuse/tumbleweed，然后打开软件管理功能，选择最新的驱动安装即可。 安装解码器：添加Packman软件源，然后再安装，其实可以直接用火狐浏览器访问opensuse-community（大概需要富强）用里面提供的按钮一键安装（自动添加软件源和安装解码器包），安装完成之后还是在YaST选择软件管理，在视图里选择软件源，选择Packman软件源，选择“切换系统包”，确保今后这些包的更新都来自Packman源。 其他的软件都没什么好说的，直接参照openSUSE维基上的第三方软件源添加即可。如果不知道有没有自己想要的软件，可以访问 openSUSE软件，除了官方提供的源可以使用网页上的按钮一键安装，也可以使用社区软件包（类似于Arch的AUR），或者也可以使用snap来补充软件比如Visual Studio Code或者Typora（之前看到b站上的视频说openSUSE上Typora没人打包，大概是因为snap上就有），参照 Installing snap on openSUSE。 snap加速：为snap设置代理 sudo snap set system proxy.https=socks5://127.0.0.1:1080\rsudo snap set system proxy.http=socks5://127.0.0.1:1080\r ","date":"2021-03-07","objectID":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/:3:0","tags":["Linux","openSUSE"],"title":"openSUSE Tumbleweed桌面安装要点记录","uri":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"},{"categories":["学习记录","日常"],"content":"滚动升级 openSUSE Tumbleweed是滚动升级的版本，使用 pacman -Syu zypper dup升级系统。 ","date":"2021-03-07","objectID":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/:4:0","tags":["Linux","openSUSE"],"title":"openSUSE Tumbleweed桌面安装要点记录","uri":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"},{"categories":["学习记录","日常"],"content":"总结 个人觉得安装和使用都是比较好上手的，默认的KDE Plasma就足够好看了，中文字体的显示效果也很不错（manjaro默认的中文字体显示效果让我很不满意，包括KDE Plasma版和Gnome版），几乎不需要再多折腾。安装软件虽然没有AUR来的爽，但是有图形界面与网页一键安装，易用性不错。而且软件包也足够新，昨天装上后就直接用上了KDE Plasma 5.21和5.10Linux内核，够爽，一点没有老牌发行版背着沉重的历史包袱的感觉，整体给我的印象非常好。 ","date":"2021-03-07","objectID":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/:5:0","tags":["Linux","openSUSE"],"title":"openSUSE Tumbleweed桌面安装要点记录","uri":"/posts/opensuse-tumbleweed%E6%A1%8C%E9%9D%A2%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"},{"categories":["学习记录","日常"],"content":"Manjaro使用第一日总结 ","date":"2021-02-24","objectID":"/posts/manjaro%E7%AC%AC%E4%B8%80%E6%97%A5%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:0","tags":["Linux","Manjaro"],"title":"Manjaro使用第一日总结","uri":"/posts/manjaro%E7%AC%AC%E4%B8%80%E6%97%A5%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["学习记录","日常"],"content":"安装后第一件事 换国内源 sudo pacman-mirrors -i -c China -m rank\rsudo pacman -Syy\rsudo pacman -Syu\r安装中文输入法 安装fcitx-libpinyin（也可以是sunpinyin等） 安装kcm-fcitx（kde桌面的输入法管理） 编辑配置文件~/.pam_environment GTK_IM_MODULE DEFAULT=fcitx\rQT_IM_MODULE DEFAULT=fcitx\rXMODIFIERS DEFAULT=@im=fcitx\r重新登录生效 如果不是有旺盛的中文输入需求就不要折腾搜狗输入法了 ","date":"2021-02-24","objectID":"/posts/manjaro%E7%AC%AC%E4%B8%80%E6%97%A5%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:0","tags":["Linux","Manjaro"],"title":"Manjaro使用第一日总结","uri":"/posts/manjaro%E7%AC%AC%E4%B8%80%E6%97%A5%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["学习记录","日常"],"content":"总结 如非必要，不要随意添加archlinuxcn源 谨慎对待搜索引擎上的教程，比起轻率的敲安装命令不如使用图形界面的“添加/删除软件功能”搜索包后安装 比起用搜索引擎搜索出一大堆过时的文章，不如直接去蹭archlinux wiki的课，例如中文输入法的问题，搜索引擎上有一大堆折腾搜狗输入法的文章与过时文章（还有过于激进的解决方案），其实直接参阅archlinux wiki的fcitx章节就可以轻松无痛的解决基本的中文输入的需求（只要不是非搜狗输入法不可），不过arch与manjaro毕竟不是一个系统，在实践wiki上的方法先去搜索相应的包，再决定是否安装。 ","date":"2021-02-24","objectID":"/posts/manjaro%E7%AC%AC%E4%B8%80%E6%97%A5%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:0","tags":["Linux","Manjaro"],"title":"Manjaro使用第一日总结","uri":"/posts/manjaro%E7%AC%AC%E4%B8%80%E6%97%A5%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["学习记录"],"content":"为什么是Groovy？ 要说Groovy一直都不是多火的东西，同时作为JVM上的语言，完全没有近年来谷歌强推的Kotlin火，但是学语言嘛，最重要的是开心，特别是工作中不是必须要用的语言。平常自己写一些辅助工作的小功能会用Java，像这类东西肯定是脚本语言更加适合，也自己学了一点热门的Python，但毕竟工作中一点都不用，想写个功能还得翻翻文档，而Java工作中常用，api根本不用看直接用，Python的效率优势反而没了，结果工作中常用的Java和JavaScript越来越熟练，Python就荒废了。但不得不说Java在写一些功能的时候是真的不爽，比如集合操作，工作中也写一点JavaScript，比较之下就更加不爽，之后Groovy在偶然的机会下就进入视线，试着用了一下，还真挺有意思，就开始想着认真学一下，要说自己为什么想学Groovy，大概就下面几点： 脚本语言，直接写直接用 兼容Java语法，学习曲线平滑 介绍中看到DSL相关的东西，觉得能拿来做些有意思的东西 看到有不少用Groovy给Java写单元测试的用法，感觉可以给工作上带来帮助 而且在网上还看到一个很有意思的说法，Groovy是真正的JavaScript，我也总结了一下： 虚假的JavaScript 真正的JavaScript 可以在各种浏览器上运行，靠v8引擎和node.js也可以在服务端运行，但就是不能在JVM上运行 在JVM上运行 语法与api和Java有相似之处，但也有大量不同的地方 可以直接写Java代码 动态语言 动态语言，但是可以设置静态编译，能屈能伸 蹭热度的名字，一开始叫LiveScript groovy：adj.时髦的; 吸引人的; 有趣的 包含美好的寓意 当然上面是开玩笑的，不过也体现出了Groovy吸引Java开发人员的地方。 ","date":"2019-07-07","objectID":"/posts/groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/:0:1","tags":["Groovy"],"title":"Groovy学习记录（一）","uri":"/posts/groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/"},{"categories":["学习记录"],"content":"快速开始 确实够快，因为做Java开发，肯定是有JDK的，只要再下载一个Groovy 50多M的包，解压之后把bin目录配置进Path变量就行了。 输入 groovy -v 展示了Groovy Java和系统版本，安装成功。 安装好之后就有命令行Groovy Shell和图形界面的Groovy Console可以用，也可以直接文本编辑器写groovy文件，例如： print 'Hello World' 然后切换到文件所在目录输入命令 groovy hello.groovy 运行展示结果。 初步学习就是看官方文档，先把 Differences with Java 和 The Groovy Development Kit 这两篇看个差不多就可以开始写脚本了。 自己写了两个小东西，主要是处理xml配置文件的，用到了 Processing XML 里面介绍的XmlSlurper，用起来很爽，基本上就是 def list = new XmlSlurper().parseText(text) //解析xml文本 println list.technology.name //直接取值 println list.technology.@name //取属性 list.technology.each { it -\u003e println it.@name //直接遍历 } 就行了，简单愉快。 遍历目录： //遍历所有文件和文件夹 new File('/path').eachFileRecurse { file -\u003e println file.name } 定义集合与遍历集合： //列表 def list = [5, 6, 7, 8] list.each { println \"Item: $it\" } //Map def map = [name: 'Gromit', likes: 'cheese', id: 1234] def map2 = [ simple : 123, complex: [a: 1, b: 2] ] map.each { key, value -\u003e println \"key: $key val: $value\" } 舒服了。 还有个用的比较多的就是GString，Groovy中单引号是普通字符串，双引号是GString，可以直接用类似字符串模板的写法，上面已经出现过了: def map = [name: 'Gromit', likes: 'cheese', id: 1234] map.each { key, value -\u003e println \"key: $key val: ${value.toUpperCase()}\" } 有了这些其实就已经能提高不少效率了，而且为什么说Groovy学习曲线平滑？因为有的地方如果不太熟悉Groovy的api，可以去翻文档，也可以直接上自己熟悉的Java写法搞定的，效率UP。 ","date":"2019-07-07","objectID":"/posts/groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/:0:2","tags":["Groovy"],"title":"Groovy学习记录（一）","uri":"/posts/groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/"},{"categories":["学习记录"],"content":"Groovy in Action Groovy中文资料还是有点少，Groovy in Action第一版倒是有中文的，但那都是07年的书了，年代有点久远，所以干脆就直接挑战一下Groovy in Action 第二版的英文版，锻炼一下自己阅读英文书籍的能力。目前看完了Part1的第一章和第二章。 第一章基本就是Groovy大型广告，介绍了Groovy的故事，Groovy的使用场景，快速开始和支持Groovy的IDE与文本编辑器的介绍。 第二章也是介绍了Groovy的一些基础内容，到没有一上来就讲什么运算符数据类型之类了，而是讲了和Java语法的比较，assert的用法，还有一些GroovyBeans，注解，grapes，GStrings，正则表达式，数字，集合，闭包，流程控制语句大致的介绍，其中有一点就是Groovy中的数字类型也是对象，所以会看到 1.plus(2) 这种看着怪怪的写法。 接下来就是Groovy编译器相关的内容。这里说到了有意思的一点，Groovy虽然是动态语言，但是与用解释器逐行解释的动态语言不同，Groovy是经过编译器编译再运行的，但是编译之后又怎么做到动态语言的特性的呢？以调用方法为例子，编译后的文件里不是直接调用的，而是 getMetaClass().invokeMethod(this, \"foo\", EMPTY_PARAMS_ARRAY) 这样通过MetaClass对象进行调用，通过MetaClass对象可以实现动态语言的特性。 而使用注解 @CompileStatic 之后编译出来的文件就不去使用MetaClass对象调用方法。 总之趁着自己还有学习热情的时候多看点吧。 ","date":"2019-07-07","objectID":"/posts/groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/:0:3","tags":["Groovy"],"title":"Groovy学习记录（一）","uri":"/posts/groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/"},{"categories":["工作记录"],"content":"目前做的是网金方面的外包，因为涉及敏感信息，所以就在不涉及到具体信息的情况下记录一下面对生产问题时，让自己印象比较深刻的一些不成熟排查的思路与解决过程，方便回顾，总结与进步。 ","date":"2019-07-05","objectID":"/posts/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95%E4%B8%80/:0:0","tags":["Java","Apache"],"title":"生产问题排查记录（一）","uri":"/posts/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95%E4%B8%80/"},{"categories":["工作记录"],"content":"问题描述：客户无法登录，错误提示信息为空 背景信息 收到客户反馈，无法登录并且弹出了空的错误信息，具体询问客户表示在某个时间点之前可以正常使用，但是那之后就无法使用了。 网络大致架构为： 服务H（Apache 静态资源服务器） -\u003e 服务G（Weblogic 主要负责会话控制等公共业务） -\u003e 服务S（Weblogic 负责具体业务逻辑） 由于服务S负责具体的业务逻辑，所以在服务G上的日志可以很方便的检索与跟踪，服务G上由于主要负责一些简单流程，日志记录格式不好，查找也不怎么方便。而Apache上就只有http请求日志。这就造成了在查找日志跟踪问题时并不是H到G再到S的正常顺序，而是按照日志获取难易程度进行查找的，也就是反过来的S到G再到H，这样做的弊端也就在这次错误排查中显现了。 排查过程 首先找到了客户的登录请求，请求成功到服务S并且成功返回，查看时间戳，也在正常时间内执行完毕，没有超时，看上去一切正常，可是客户的浏览器并未受到这一笔返回报文。接着排查服务G，寻找到服务G上客户的请求信息，也是正常接收请求，在正常的时间内返回，看上去也是一切正常。这时候本应该继续排查服务H，跟踪客户的http请求响应码是否正常，但是由于经验不足，同时http请求量较大，不便排查，而且服务H上没有任何业务逻辑，惯性思维下也就暂时忽略了服务H的排查，事实证明就是这一点导致走了弯路。然后此时就只能推测是客户的网络问题，询问后得知在相同设备上换别的账户可以登录，同时此账户在别的设备别的网络上也无法登录。 暂时没有了其他线索，只能再去仔细排查一遍代码。排查之后发现了重要的一点，在登录成功之后服务G向服务S请求了一部分客户数据放入会话，而这一请求可能会导致拖慢请求速度，为了保证性能，服务S提供数据的接口有一个标志位，可以在放弃一部分在某些场景下不需要的数据来提高性能。可是服务S上这个接口的标志位字段在不知道什么时候修改过， 而服务G在请求时的字段居然没有修改！ 这就导致了这个标志位失效，所有的请求都会变得较为耗时。回过头去看服务G上的日志，发现这名客户因为其账户原因，正好这一请求较为耗时，但是并未超时。最终还是去排查了服务H，发现 使用的Apache服务器在前几天升级了版本，然而开发人员居然不知情！ 而Apache服务器升级的日志就是客户无法正常使用的时间点。排查其配置文件，发现配置的超时时间比之前短了一倍以上，这就导致Apache超时时间短于Weblogic超时时间，而客户的登录请求时间正好比Apache超时时间长了一点，这就导致Weblogic上虽然没超时，Apache上已经判定为超时并返回错误码了，而Apache返回的http错误码在前端代码的ajax请求回调内并未妥善处理，导致了一个意义不明的提示信息。 解决方案 现在问题就很简单了，首先把Apache超时时间调整到合适的时间，调整完成后得到客户反馈，问题解决。然后就是修改代码，修复不一致的标志位，去掉不必要的数据请求，降低交易时间，搞定，提交上线申请。 反思与总结 回过头来看下其实是个并不复杂的问题，如果排查顺序正常，就能很快查出问题所在，如果知道Apache服务器最近升级版本，也能很快察觉到问题所在，如果能一直及时维护的接口文档，就能从根源上杜绝这个问题的发生。 ","date":"2019-07-05","objectID":"/posts/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95%E4%B8%80/:0:1","tags":["Java","Apache"],"title":"生产问题排查记录（一）","uri":"/posts/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95%E4%B8%80/"},{"categories":["日常"],"content":"经历了一点微小的困难终于能写第一篇博客了，无内鬼，来点MarkDown语法 这是一级标题 ","date":"2019-07-05","objectID":"/posts/helloworld/:0:0","tags":["MarkDown"],"title":"helloworld","uri":"/posts/helloworld/"},{"categories":["日常"],"content":"这是二级 ","date":"2019-07-05","objectID":"/posts/helloworld/:1:0","tags":["MarkDown"],"title":"helloworld","uri":"/posts/helloworld/"},{"categories":["日常"],"content":"这是三级 这是四级 # 这是一级标题 ## 这是二级 ### 这是三级 #### 这是四级 上面是分割线 *** 上面是分割线 下面是无序列表 1 2 3 下面是有序列表 one two three 下面是无序列表 - 1 - 2 - 3 下面是有序列表 1. one 2. two 3. three 这里是引用 这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用 \u003e这里是引用 \u003e这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用 这是粗体 这是斜体 **这是粗体** *这是斜体* 下面是链接 我的博客 下面是图片 下面是链接 [我的博客](https://jgduhao.github.io/) 下面是图片 ![截图](https://jgduhao.github.io/images/2019-07-05_090016.png) 下面就是代码 println 'Hello World'; 够用了，重要的还是内容 ","date":"2019-07-05","objectID":"/posts/helloworld/:1:1","tags":["MarkDown"],"title":"helloworld","uri":"/posts/helloworld/"}]