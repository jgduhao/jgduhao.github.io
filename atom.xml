<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hao&#39;s blog</title>
  
  <subtitle>jgduhao&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jgduhao.github.io/"/>
  <updated>2019-07-07T10:07:58.680Z</updated>
  <id>https://jgduhao.github.io/</id>
  
  <author>
    <name>Hao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Groovy学习记录（一）</title>
    <link href="https://jgduhao.github.io/2019/07/07/Groovy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://jgduhao.github.io/2019/07/07/Groovy学习记录（一）/</id>
    <published>2019-07-07T08:06:41.000Z</published>
    <updated>2019-07-07T10:07:58.680Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么是Groovy？"><a href="#为什么是Groovy？" class="headerlink" title="为什么是Groovy？"></a>为什么是Groovy？</h3><p>要说Groovy一直都不是多火的东西，同时作为JVM上的语言，完全没有近年来谷歌强推的Kotlin火，但是学语言嘛，最重要的是开心，特别是工作中不是必须要用的语言。平常自己写一些辅助工作的小功能会用Java，像这类东西肯定是脚本语言更加适合，也自己学了一点热门的Python，但毕竟工作中一点都不用，想写个功能还得翻翻文档，而Java工作中常用，api根本不用看直接用，Python的效率优势反而没了，结果工作中常用的Java和JavaScript越来越熟练，Python就荒废了。但不得不说Java在写一些功能的时候是真的不爽，比如集合操作，工作中也写一点JavaScript，比较之下就更加不爽，之后Groovy在偶然的机会下就进入视线，试着用了一下，还真挺有意思，就开始想着认真学一下，要说自己为什么想学Groovy，大概就下面几点：</p><ul><li>脚本语言，直接写直接用</li><li>兼容Java语法，学习曲线平滑</li><li>介绍中看到DSL相关的东西，觉得能拿来做些有意思的东西</li><li>看到有不少用Groovy给Java写单元测试的用法，感觉可以给工作上带来帮助</li></ul><p>而且在网上还看到一个很有意思的说法，Groovy是真正的JavaScript，我也总结了一下：</p><table><thead><tr><th>虚假的JavaScript</th><th>真正的JavaScript</th></tr></thead><tbody><tr><td>可以在各种浏览器上运行，靠v8引擎和node.js也可以在服务端运行，但就是不能在JVM上运行</td><td>在JVM上运行</td></tr><tr><td>语法与api和Java有相似之处，但也有大量不同的地方</td><td>可以直接写Java代码</td></tr><tr><td>动态语言</td><td>动态语言，但是可以设置静态编译，能屈能伸</td></tr><tr><td>蹭热度的名字，一开始叫LiveScript</td><td>groovy：adj.时髦的; 吸引人的; 有趣的 包含美好的寓意</td></tr></tbody></table><p>当然上面是开玩笑的，不过也体现出了Groovy吸引Java开发人员的地方。</p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>确实够快，因为做Java开发，肯定是有JDK的，只要再下载一个Groovy 50多M的包，解压之后把bin目录配置进Path变量就行了。<br>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groovy -v</span><br></pre></td></tr></table></figure><p>展示了Groovy Java和系统版本，安装成功。<br>安装好之后就有命令行Groovy Shell和图形界面的Groovy Console可以用，也可以直接文本编辑器写groovy文件，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &apos;Hello World&apos;</span><br></pre></td></tr></table></figure><p>然后切换到文件所在目录输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groovy hello.groovy</span><br></pre></td></tr></table></figure><p>运行展示结果。</p><p>初步学习就是看官方文档，先把<br><a href="http://www.groovy-lang.org/differences.html" target="_blank" rel="noopener">Differences with Java</a><br>和<br><a href="http://www.groovy-lang.org/groovy-dev-kit.html" target="_blank" rel="noopener">The Groovy Development Kit</a><br>这两篇看个差不多就可以开始写脚本了。<br>自己写了两个小东西，主要是处理xml配置文件的，用到了<br><a href="http://www.groovy-lang.org/processing-xml.html" target="_blank" rel="noopener">Processing XML</a><br>里面介绍的XmlSlurper，用起来很爽，基本上就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def list = new XmlSlurper().parseText(text) //解析xml文本</span><br><span class="line">println list.technology.name //直接取值</span><br><span class="line">println list.technology.@name //取属性</span><br><span class="line">list.technology.each &#123; it -&gt;</span><br><span class="line">    println it.@name //直接遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就行了，简单愉快。<br>遍历目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//遍历所有文件和文件夹</span><br><span class="line">new File(&apos;/path&apos;).eachFileRecurse &#123; file -&gt;                      </span><br><span class="line">    println file.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义集合与遍历集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//列表</span><br><span class="line">def list = [5, 6, 7, 8]</span><br><span class="line">list.each &#123;</span><br><span class="line">    println &quot;Item: $it&quot; </span><br><span class="line">&#125;</span><br><span class="line">//Map</span><br><span class="line">def map = [name: &apos;Gromit&apos;, likes: &apos;cheese&apos;, id: 1234]</span><br><span class="line">def map2 = [</span><br><span class="line">        simple : 123,</span><br><span class="line">        complex: [a: 1, b: 2]</span><br><span class="line">]</span><br><span class="line">map.each &#123; key, value -&gt;</span><br><span class="line">    println &quot;key: $key val: $value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>舒服了。<br>还有个用的比较多的就是GString，Groovy中单引号是普通字符串，双引号是GString，可以直接用类似字符串模板的写法，上面已经出现过了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def map = [name: &apos;Gromit&apos;, likes: &apos;cheese&apos;, id: 1234]</span><br><span class="line">map.each &#123; key, value -&gt;</span><br><span class="line">    println &quot;key: $key val: $&#123;value.toUpperCase()&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这些其实就已经能提高不少效率了，而且为什么说Groovy学习曲线平滑？因为有的地方如果不太熟悉Groovy的api，可以去翻文档，也可以直接上自己熟悉的Java写法搞定的，效率UP。</p><h3 id="Groovy-in-Action"><a href="#Groovy-in-Action" class="headerlink" title="Groovy in Action"></a>Groovy in Action</h3><p>Groovy中文资料还是有点少，Groovy in Action第一版倒是有中文的，但那都是07年的书了，年代有点久远，所以干脆就直接挑战一下Groovy in Action 第二版的英文版，锻炼一下自己阅读英文书籍的能力。目前看完了Part1的第一章和第二章。<br>第一章基本就是Groovy大型广告，介绍了Groovy的故事，Groovy的使用场景，快速开始和支持Groovy的IDE与文本编辑器的介绍。<br>第二章也是介绍了Groovy的一些基础内容，到没有一上来就讲什么运算符数据类型之类了，而是讲了和Java语法的比较，assert的用法，还有一些GroovyBeans，注解，grapes，GStrings，正则表达式，数字，集合，闭包，流程控制语句大致的介绍，其中有一点就是Groovy中的数字类型也是对象，所以会看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.plus(2)</span><br></pre></td></tr></table></figure><p>这种看着怪怪的写法。<br>接下来就是Groovy编译器相关的内容。这里说到了有意思的一点，Groovy虽然是动态语言，但是与用解释器逐行解释的动态语言不同，Groovy是经过编译器编译再运行的，但是编译之后又怎么做到动态语言的特性的呢？以调用方法为例子，编译后的文件里不是直接调用的，而是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getMetaClass().invokeMethod(this, &quot;foo&quot;, EMPTY_PARAMS_ARRAY)</span><br></pre></td></tr></table></figure><p>这样通过MetaClass对象进行调用，通过MetaClass对象可以实现动态语言的特性。<br>而使用注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@CompileStatic</span><br></pre></td></tr></table></figure><p>之后编译出来的文件就不去使用MetaClass对象调用方法。  </p><p>总之趁着自己还有学习热情的时候多看点吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么是Groovy？&quot;&gt;&lt;a href=&quot;#为什么是Groovy？&quot; class=&quot;headerlink&quot; title=&quot;为什么是Groovy？&quot;&gt;&lt;/a&gt;为什么是Groovy？&lt;/h3&gt;&lt;p&gt;要说Groovy一直都不是多火的东西，同时作为JVM上的语言，完全没
      
    
    </summary>
    
      <category term="学习记录" scheme="https://jgduhao.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Groovy" scheme="https://jgduhao.github.io/tags/Groovy/"/>
    
  </entry>
  
  <entry>
    <title>生产问题排查记录（一）</title>
    <link href="https://jgduhao.github.io/2019/07/05/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://jgduhao.github.io/2019/07/05/生产问题排查记录（一）/</id>
    <published>2019-07-05T09:09:54.000Z</published>
    <updated>2019-07-05T13:58:46.816Z</updated>
    
    <content type="html"><![CDATA[<p>目前做的是网金方面的外包，因为涉及敏感信息，所以就在不涉及到具体信息的情况下记录一下面对生产问题时，让自己印象比较深刻的一些不成熟排查的思路与解决过程，方便回顾，总结与进步。</p><h3 id="问题描述：客户无法登录，错误提示信息为空"><a href="#问题描述：客户无法登录，错误提示信息为空" class="headerlink" title="问题描述：客户无法登录，错误提示信息为空"></a>问题描述：客户无法登录，错误提示信息为空</h3><h4 id="背景信息"><a href="#背景信息" class="headerlink" title="背景信息"></a>背景信息</h4><p>收到客户反馈，无法登录并且弹出了空的错误信息，具体询问客户表示在某个时间点之前可以正常使用，但是那之后就无法使用了。<br>网络大致架构为：<br>服务H（Apache 静态资源服务器） -&gt;  服务G（Weblogic 主要负责会话控制等公共业务） -&gt; 服务S（Weblogic 负责具体业务逻辑）<br>由于服务S负责具体的业务逻辑，所以在服务G上的日志可以很方便的检索与跟踪，服务G上由于主要负责一些简单流程，日志记录格式不好，查找也不怎么方便。而Apache上就只有http请求日志。这就造成了在查找日志跟踪问题时并不是H到G再到S的正常顺序，而是按照日志获取难易程度进行查找的，也就是反过来的S到G再到H，这样做的弊端也就在这次错误排查中显现了。  </p><h4 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h4><p>首先找到了客户的登录请求，请求成功到服务S并且成功返回，查看时间戳，也在正常时间内执行完毕，没有超时，看上去一切正常，可是客户的浏览器并未受到这一笔返回报文。接着排查服务G，寻找到服务G上客户的请求信息，也是正常接收请求，在正常的时间内返回，看上去也是一切正常。这时候本应该继续排查服务H，跟踪客户的http请求响应码是否正常，但是由于经验不足，同时http请求量较大，不便排查，而且服务H上没有任何业务逻辑，惯性思维下也就暂时忽略了服务H的排查，事实证明就是这一点导致走了弯路。然后此时就只能推测是客户的网络问题，询问后得知在相同设备上换别的账户可以登录，同时此账户在别的设备别的网络上也无法登录。<br>暂时没有了其他线索，只能再去仔细排查一遍代码。排查之后发现了重要的一点，在登录成功之后服务G向服务S请求了一部分客户数据放入会话，而这一请求可能会导致拖慢请求速度，为了保证性能，服务S提供数据的接口有一个标志位，可以在放弃一部分在某些场景下不需要的数据来提高性能。可是服务S上这个接口的标志位字段在不知道什么时候修改过，<strong>而服务G在请求时的字段居然没有修改！</strong>这就导致了这个标志位失效，所有的请求都会变得较为耗时。回过头去看服务G上的日志，发现这名客户因为其账户原因，正好这一请求较为耗时，但是并未超时。最终还是去排查了服务H，发现<strong>使用的Apache服务器在前几天升级了版本，然而开发人员居然不知情！</strong>而Apache服务器升级的日志就是客户无法正常使用的时间点。排查其配置文件，发现配置的超时时间比之前短了一倍以上，这就导致Apache超时时间短于Weblogic超时时间，而客户的登录请求时间正好比Apache超时时间长了一点，这就导致Weblogic上虽然没超时，Apache上已经判定为超时并返回错误码了，而Apache返回的http错误码在前端代码的ajax请求回调内并未妥善处理，导致了一个意义不明的提示信息。  </p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>现在问题就很简单了，首先把Apache超时时间调整到合适的时间，调整完成后得到客户反馈，问题解决。然后就是修改代码，修复不一致的标志位，去掉不必要的数据请求，降低交易时间，搞定，提交上线申请。  </p><h4 id="反思与总结"><a href="#反思与总结" class="headerlink" title="反思与总结"></a>反思与总结</h4><p>回过头来看下其实是个并不复杂的问题，如果排查顺序正常，就能很快查出问题所在，如果知道Apache服务器最近升级版本，也能很快察觉到问题所在，如果能一直及时维护的接口文档，就能从根源上杜绝这个问题的发生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前做的是网金方面的外包，因为涉及敏感信息，所以就在不涉及到具体信息的情况下记录一下面对生产问题时，让自己印象比较深刻的一些不成熟排查的思路与解决过程，方便回顾，总结与进步。&lt;/p&gt;
&lt;h3 id=&quot;问题描述：客户无法登录，错误提示信息为空&quot;&gt;&lt;a href=&quot;#问题描述：
      
    
    </summary>
    
      <category term="工作记录" scheme="https://jgduhao.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Java" scheme="https://jgduhao.github.io/tags/Java/"/>
    
      <category term="Apache" scheme="https://jgduhao.github.io/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>helloworld</title>
    <link href="https://jgduhao.github.io/2019/07/05/helloworld/"/>
    <id>https://jgduhao.github.io/2019/07/05/helloworld/</id>
    <published>2019-07-05T00:26:59.000Z</published>
    <updated>2019-07-05T02:54:00.462Z</updated>
    
    <content type="html"><![CDATA[<p>经历了一点微小的困难终于能写第一篇博客了，无内鬼，来点MarkDown语法</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级"><a href="#这是二级" class="headerlink" title="这是二级"></a>这是二级</h2><h3 id="这是三级"><a href="#这是三级" class="headerlink" title="这是三级"></a>这是三级</h3><h4 id="这是四级"><a href="#这是四级" class="headerlink" title="这是四级"></a>这是四级</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line"></span><br><span class="line">## 这是二级</span><br><span class="line"></span><br><span class="line">### 这是三级</span><br><span class="line"></span><br><span class="line">#### 这是四级</span><br></pre></td></tr></table></figure><hr><p>上面是分割线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">上面是分割线</span><br></pre></td></tr></table></figure><p>下面是无序列表</p><ul><li>1</li><li>2</li><li>3</li></ul><p>下面是有序列表</p><ol><li>one</li><li>two</li><li>three</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">下面是无序列表</span><br><span class="line">- 1</span><br><span class="line">- 2</span><br><span class="line">- 3</span><br><span class="line"></span><br><span class="line">下面是有序列表</span><br><span class="line">1. one</span><br><span class="line">2. two</span><br><span class="line">3. three</span><br></pre></td></tr></table></figure><blockquote><p>这里是引用</p></blockquote><blockquote><p>这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这里是引用</span><br><span class="line"></span><br><span class="line">&gt;这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用这就是段落引用</span><br></pre></td></tr></table></figure><p><strong>这是粗体</strong></p><p><em>这是斜体</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**这是粗体**</span><br><span class="line"></span><br><span class="line">*这是斜体*</span><br></pre></td></tr></table></figure><p>下面是链接</p><p><a href="https://jgduhao.github.io/">我的博客</a></p><p>下面是图片</p><p><img src="https://jgduhao.github.io/images/2019-07-05_090016.png" alt="截图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">下面是链接</span><br><span class="line"></span><br><span class="line">[我的博客](https://jgduhao.github.io/)</span><br><span class="line"></span><br><span class="line">下面是图片</span><br><span class="line"></span><br><span class="line">![截图](https://jgduhao.github.io/images/2019-07-05_090016.png)</span><br></pre></td></tr></table></figure><p>下面就是代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println &apos;Hello World&apos;;</span><br></pre></td></tr></table></figure><p>够用了，重要的还是内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经历了一点微小的困难终于能写第一篇博客了，无内鬼，来点MarkDown语法&lt;/p&gt;
&lt;h1 id=&quot;这是一级标题&quot;&gt;&lt;a href=&quot;#这是一级标题&quot; class=&quot;headerlink&quot; title=&quot;这是一级标题&quot;&gt;&lt;/a&gt;这是一级标题&lt;/h1&gt;&lt;h2 id=&quot;这是二级
      
    
    </summary>
    
      <category term="日常" scheme="https://jgduhao.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="MarkDown" scheme="https://jgduhao.github.io/tags/MarkDown/"/>
    
  </entry>
  
</feed>
